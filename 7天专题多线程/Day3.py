'''第三天'''
'''
1.什么是线程安全，什么是互斥锁
答：
1.互斥锁是一种独占锁，同一时刻只有一个线程可以访问共享的数据。
每个对象都对应于一个可被称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
2.同一个进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程
操作尚未结束，另一个线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证
每个线程对该对象的操作都得到正确的结果。
'''
'''
2.什么是多线程竞争？怎么解决？
答：线程是非独立的，同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态，
数据几乎同步会被多个线程占用，造成数据混乱，即所谓的线程不安全。
那怎么解决多线程竞争问题？锁
锁的好处：确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题
锁的坏处：阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大下降了
锁的致命问题：死锁，互相握住了对方要的资源，互相不放开，死循环了。
'''
'''
3.代码演示多线程共同操作同一个数据互斥锁同步？
下面的例子创建了5个线程，每个线程会尝试去将num+1，
如果没有if mutex.acquire(1):这个判断，就有可能会导致多线程数据不同步的问题。
'''
import threading
import time


class MyThread(threading.Thread):
    def __init__(self, num):
        threading.Thread.__init__(self)#不然会报错RuntimeError: thread.__init__() not called
        self.number = num

    def run(self):
        global num
        time.sleep(1)  # 结果是同时出来的，十秒后结果同时出现
        if mutex.acquire():
            num += self.number
            msg = self.name + ' set num to ' + str(num)
            print(msg)
            mutex.release()
        #没有加锁的话，执行顺序乱七八糟
        # num += self.number
        # msg = self.name + ' set num to ' + str(num)
        # print(msg)


num = 0
mutex = threading.Lock()

for i in range(6):
    t = MyThread(i)
    t.start()

'''
线程之间因为资源共享，所以会出现线程竞争问题，
也就是当各个线程访问数据资源的时候，这个数据被多个线程占用，
造成最后数据乱七八糟的情况。所以引入了锁的机制来解决这个问题。
锁能确保某段关键代码只能由一个线程从头到尾完整地执行，
但是阻止了多线程并发执行。而且可能导致两个线程互相锁上了对方需要的资源，
导致两个线程僵持住
'''
